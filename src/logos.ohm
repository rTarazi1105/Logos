Logos {
	Program = Section+
	Section
		= DataDeclLine
		| StructDecl
		| EnumDecl
		| ClassDecl
		| MethodDecl
		| ModDecl
		| ClassImpl
	comment = "//" notNewLine*
	notNewLine = ~("\n" | "\r") any
	space += comment
		
		
	Statement
		= ParenStatement
		| Bool
		| Equality
		| FilledInfix
		| FilledRelationOpOrProp
		| Negation
		| DataVar
	ParenStatement = "(" Statement ")"
	Negation = "not" Statement
	
	FilledRelationOpOrProp = DataVar "[" ListOf<DataVar, ","> "]"
	
	FilledInfix = Statement Infix Statement				// only works on binary operations
	
	Equality = DataVar "=" DataVar
	
	Infix
		= DefaultInfix
		| UserDefinedInfix
	DefaultInfix
		= "and"							// and
		| "or"							// or
		| "=="							// equals for statements
	
	DataDeclLine = DataDecl ";"
	DataDecl
		= ValueDecl
		| RelationDecl
		| OperationDecl
		| InfixDecl
		| PropertyDecl
		| StatementDecl
		| Assume
		
	ValueDecl = "value" id1 (":" DataVar)?
	RelationDecl = id1 ":" ListOf<id1, ","> ":" Statement
	OperationDecl = OperationWord id2 ":" ListOf<id1, ","> ":" Statement
	InfixDecl = "infix" id2 Operation
	PropertyDecl = PropertyWord id1 ":" ListOf<ArgRelation, ","> ":" Statement
	ArgRelation = id1 Numbering
	StatementDecl = id1 ":" Statement
	Assume = "assume" id1? Bool ":" Statement
	
	Numbering = "<" number ">"
	
	StructDecl = "struct" id2 TypeParam? "{" ListOf<Param, ","> "}" 
	EnumDecl = "enum" id2 TypeParam? "{" ListOf<Param, ","> "}"
	
	ModDecl = "mod" id2 ModHead ModBody
	ModHead = TypeParam? "(" ListOf<ModParamWithSelf, ","> ")" ReturnType?
	// OptModParams = ListOf<ModParam, ",">
	
	MethodDecl = "mod" FilledCustomType "." id2 ModHead ModBody
	
	ModParamWithSelf = ModParam | SelfParam
	
	ReturnType = "->" Mutable? ValidType
	
	ClassDecl = "class" id2 TypeParam? SuperClass? ClassBody
	SuperClass = ":" ListOf<FilledClass, "+">
	ClassBody = "{" ClassMod* "}"
	ClassMod = "mod" id2 ModHead ModBodyOrColon
	ModBodyOrColon = ModBody | ";"
	
	ClassImpl = FilledCustomType "impl" FilledClass ClassBody
	
	TypeParam = "<" ListOf<IdAndSuperClass, ","> ">"		// no superclass = Any
	IdAndSuperClass = id3 SuperClass?
	TypeArgs = "<" ListOf<ValidType, ","> ">"	// FilledTypeParam
	
	Param = (id2 ":")? ValidType				// if no id: let it be 0,1 etc
	SelfParam = Mutable? "self"
	ModParam = id2 ":" Mutable? ValidType
	Mutable = "mut"
	
	ValidType
		= DefaultValidType
		| ArrayType
		| FilledCollection
		| FilledCustomType
	FilledCollection = CollectionClass TypeArgs?
	FilledCustomType = CustomType TypeArgs?
	
	DefaultValidType
		= "value"
		| "statement"
		| NumberedRelation
		| OperationWord
		| PropertyWord
		| "bool"
		| "int"
		| SelfType
		| NoneType
		| ErrorClass
		| ComparableClass
		| EquatableClass
	NumberedRelation = "relation" Numbering?
	OperationWord = "op " | "operation "
	PropertyWord = "prop " | "property "
	ArrayType = "[" ValidType ";" number? "]"
	
	ModBody = "{" ActionLine* "}"
	ActionLine = Action ";"
	Action
		= ModBody
		| DataDecl
		| Assignment
		| Increment | Decrement
		| Return
		| ControlFlow
		| BreakLine
		| ContinueLine
		| MethodCall
		| ModCall
	MethodCall = Variable "." id2 Call
	ModCall = id2 Call
	Call = "(" ListOf<Readable, ","> ")"
	
	Assignment = Variable "=" Readable
	Readable = Construct | Literal | ControlFlow | LogosArray | Variable
	Construct = FilledStruct "{" ListOf<Readable, ","> "}"
	Increment = Variable "++"
	Decrement = Variable "--"
	
	BreakLine = break+
	ContinueLine = continue+
	
	Return = ReturnOrYield Readable?
	ReturnOrYield = "return" | "yield"
	
	EvalBool
		= And
		| Or
		| Not
		| Bool
		| InEqualities
		| Variable		// will need to add statement.truth
	And = EvalBool1 "&" EvalBool2
	Or = EvalBool1 "|" EvalBool2
	Not = "!" EvalBool
	EvalBool1 = EvalBool
	EvalBool2 = EvalBool
		
	InEqualities = Readable InEqual Readable
	InEqual = "<" | ">" | "==" | "!="
	
	ControlFlow = IfFlow | MatchFlow | ForFlow | WhileFlow
	IfFlow = if EvalBool then Action ElseFlow?
	ElseFlow = else Action
	ForFlow = for Arg in Collection do Action
	Arg = id2
	Collection = LogosArray | Variable
	WhileFlow = while EvalBool do Action
	MatchFlow = match Variable ":" ListOf<MatchLine, ",">
	MatchLine = MatchStart "=>" Action
	MatchStart
		= ValidType
		| IfEvalBool
	IfEvalBool = if EvalBool
	
	LogosArray						// range will be built-in. Count(int), Range(int, int).
		= FullArray
		| CopiedArray
	FullArray = "[" ListOf<Readable, ","> "]"
	CopiedArray = "[" Readable ";" Int "]"
	Int
		= number
		| Variable
	
	Variable
		= MethodCall
		| VarField
		| ModCall
		| AssignedVariable
	VarField = Variable "." Field				// field, list index, enum case
	
	Literal
		= Bool
		| number
		| none
		| String
	String = "\"" char* "\""
	char = ~"\"" any
	Bool = true | false
	
	number = digit+
	id1 = ~keyword idchar+					// data in header can start with a number
	id2 = ~keyword idletter idchar*				// variables, modules etc
	id3 = ~keyword upper idchar*				// types must be capitalized
	idchar = alnum | "_"
	idletter = letter | "_"
	keyword = key " " // ~alnum
	key
		= Bool
		| Mutable
		| DefaultValidType
		| DefaultInfix
		| ReturnOrYield
		| none
		| "infix"
		| "struct"
		| "enum"
		| "method"
		| "mod"
		| "class"
		| "impl"
		| if
		| then
		| else
		| for
		| in
		| do
		| while
		| "not"
		| break
		| continue
	//	| "len"
	
	
	DataVar = Variable | id1
	Operation = Variable
	UserDefinedInfix = id2
	
	DeclaredStatement = Variable | id1
	Relation = Variable | id1
	Property = Variable | id1
	Value = Variable | id1
	
	CustomType = id3			// struct, enum or class
	AssignedVariable = id2
	Field = id2 | number
	
	none = "none"
	true = "true"
	false = "false"
	if = "if"
	else = "else"
	do = "do"
	in = "in"
	while = "while"
	break = "break"
	continue = "continue"
	SelfType = "Self"
	NoneType = "None"
	ErrorClass = "Error"
	ComparableClass = "Comparable"
	EquatableClass = "Equatable"
	CollectionClass = "Collection"
}
